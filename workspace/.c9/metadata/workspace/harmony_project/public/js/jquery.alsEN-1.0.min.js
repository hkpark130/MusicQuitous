{"changed":true,"filter":false,"title":"jquery.alsEN-1.0.min.js","tooltip":"/harmony_project/public/js/jquery.alsEN-1.0.min.js","value":"/**\n * jquery.als.js\n * http://als.musings.it\n * jQuery plugin for list scrolling (any list with any content)\n * developed for http://www.musings.it and released as a freebie\n *\n * animations: horizontal slide, vertical slide of lists\n * types of lists: images, texts, inserted as div or as ul - li\n * CONFIGURABLE PARAMETERS\n * visible_elements: number of visible elements of a list\n * scrolling_items: list scrolling step\n * orientation: list orientation (horizontal or vertical)\n * circular: yes for infinite list scrolling, no on the contrary\n * autoscroll: yes for automatic scrolling, no on the contrary\n * interval: if autoscroll \"yes\" is the time interval between scrolling movements\n * direction: if autoscroll \"yes\" is the scrolling direction (left,right,up,down)\n *\n * CONFIGURATION EXAMPLE:\n * $(\"#lista\").als({\n *\t\t\t\t\tvisible_items: 4,\n *\t\t\t\t\tscrolling_items: 2,\n *\t\t\t\t\torientation: \"horizontal\",\n *  \t\t\t\tcircular: \"yes\",\n *\t\t\t\t\tautoscroll: \"yes\",\n *\t\t\t\t\tinterval: 5000,\n *\t\t\t\t\tdirection: \"right\"\n *\t\t\t\t});\n *\n * @author Federica Sibella\n * Copyright (c) 2012 Federica Sibella - musings(at)musings(dot)it | http://www.musings.it\n * Released with double license MIT o GPLv3.\n * Date: 2012/06/15\n * @version 1.0\n *\n */\n\n\n (function($){\n\t/**********************************************************\n\t * Variabili: als (contains data of the current instance),\n\t * instance (number of the current instance),\n\t * methods (methods of als plugin)\n\t *********************************************************/\n\tvar als = [],\n\t\tinstance = 0;\n\tvar\tmethods = {\n\t\t/******************************************************\n\t\t * plugin inizialization\n\t\t * @param {Object} options: configuration options\n\t\t ******************************************************/\n\t\tinit: function(options){\n\t\t\tthis.each(function(){\n\t\t\t\tvar defaults = {\n\t\t\t\t\tvisible_items: 4,\n\t\t\t\t\tscrolling_items: 2,\n\t\t\t\t\torientation: \"horizontal\",\n\t\t\t\t\tcircular: \"yes\",\n\t\t\t\t\tautoscroll: \"no\",\n\t\t\t\t\tinterval: 5000,\n\t\t\t\t\tdirection: \"left\"\n\t\t\t\t\t\n\t\t\t\t},\n\t\t\t\t$obj = $(this),\n\t\t\t\tdata = $obj.data('als'),\n\t\t\t\t$options = $(),\n\t\t\t\t$item = $(),\n\t\t\t\t$wrapper = $(),\n\t\t\t\t$viewport = $(),\n\t\t\t\t$prev = $(),\n\t\t\t\t$next = $(),\n\t\t\t\tnum_items = 0,\n\t\t\t\tviewport_width = 0,\n\t\t\t\twrapper_width = 0,\n\t\t\t\tviewport_height = 0,\n\t\t\t\twrapper_height = 0,\n\t\t\t\ti = 0,\n\t\t\t\tcurrent = 0,\n\t\t\t\ttimer = 0;\n\n\t\t\t\t$options = $.extend(defaults, options);\n\t\t\t\t/*********************************************************************\n\t\t\t\t * configuration controls: autoscroll option implies\n\t\t\t\t * infinite circular scrolling\n\t\t\t\t *********************************************************************/\n\t\t\t\tif($options.circular == \"no\" && $options.autoscroll == \"yes\")\n\t\t\t\t{\n\t\t\t\t\t$options.circular = \"yes\";\n\t\t\t\t}\n\n\t\t\t\t/***********************************************************************************\n\t\t\t\t * define ID for the different plugin section to name them directly\n\t\t\t\t **********************************************************************************/\n\t\t\t\tif(!$obj.attr(\"id\") || $obj.attr(\"id\") == \"\")\n\t\t\t\t{\n\t\t\t\t\t$obj.attr(\"id\",\"als-container_\" + instance);\n\t\t\t\t}\n\t\t\t\t$viewport = $obj.find(\".als-viewport\").attr(\"id\",\"als-viewport_\" + instance);\n\t\t\t\t$wrapper = $obj.find(\".als-wrapper\").attr(\"id\",\"als-wrapper_\" + instance);\n\t\t\t\t$item = $obj.find(\".als-item\");\n\t\t\t\tnum_items = $item.size();\n\n\t\t\t\t/***************************************************************************************\n\t\t\t\t * configuration controls: number of visible element can not be higher than\n\t\t\t\t * total number of list element and scrolling items can not be more\n\t\t\t\t * than visible items\n\t\t\t\t ***************************************************************************************/\n\t\t\t\tif($options.visible_items > num_items)\n\t\t\t\t{\n\t\t\t\t\t$options.visible_items = num_items - 1;\n\t\t\t\t}\n\n\t\t\t\tif($options.scrolling_items > $options.visible_items)\n\t\t\t\t{\n\t\t\t\t\t$options.scrolling_items = $options.visible_items - 1;\n\t\t\t\t}\n\n\t\t\t\t/******************************************************\n\t\t\t\t * prev and next button inizialization (if present)\n\t\t\t\t ******************************************************/\n\t\t\t\t$prev = $obj.find(\".als-prev\").attr(\"data-id\",\"als-prev_\" + instance);\n\t\t\t\t$next = $obj.find(\".als-next\").attr(\"data-id\",\"als-next_\" + instance);\n\n\t\t\t\t/*********************************************************************\n\t\t\t\t * relative to chosen orientation I calculate width and height\n\t\t\t\t * of the list wrapper (wrapper) and of the list viewport\n\t\t\t\t * (viewport)\n\t\t\t\t * @param {Object} index: internal elements index\n\t\t\t\t *********************************************************************/\n\t\t\t\tswitch($options.orientation)\n\t\t\t\t{\n\t\t\t\t\tcase \"horizontal\":\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t$item.each(function(index)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\twrapper_width += $(this).outerWidth(true);\n\t\t\t\t\t\t\tif(i < $options.visible_items)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tviewport_width += $(this).outerWidth(true);\n\t\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t$(this).attr(\"id\",\"als-item_\" + instance + \"_\" + index);\n\t\t\t\t\t\t});\n\t\t\t\t\t\t$wrapper.css(\"width\", wrapper_width);\n\t\t\t\t\t\t$viewport.css(\"width\", viewport_width);\n\t\t\t\t\t\t$wrapper.css(\"height\", $item.outerHeight(true));\n\t\t\t\t\t\t$viewport.css(\"height\", $item.outerHeight(true));\n\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"vertical\":\n\t\t\t\t\t\t$item.each(function(index)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\twrapper_height += $(this).outerHeight(true);\n\t\t\t\t\t\t\tif(i < $options.visible_items)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tviewport_height += $(this).outerHeight(true);\n\t\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t$(this).attr(\"id\",\"als-item_\" + instance + \"_\" + index);\n\t\t\t\t\t\t});\n\t\t\t\t\t\t$wrapper.css(\"height\", wrapper_height);\n\t\t\t\t\t\t$viewport.css(\"height\", viewport_height);\n\t\t\t\t\t\t$wrapper.css(\"width\", $item.outerWidth(true));\n\t\t\t\t\t\t$viewport.css(\"width\", $item.outerWidth(true));\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\t/**************************************************\n\t\t\t\t * if circular == no don't show prev button\n\t\t\t\t * at the beginning\n\t\t\t\t **************************************************/\n\t\t\t\tif($options.circular == \"no\")\n\t\t\t\t{\n\t\t\t\t\t$prev.css(\"display\",\"none\");\n\t\t\t\t\tif($options.visible_items == num_items)\n\t\t\t\t\t{\n\t\t\t\t\t\t$next.css(\"display\",\"none\");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/**************************************************\n\t\t\t\t * saving instance parameters in a variable (data)\n\t\t\t\t * for future use\n\t\t\t\t **************************************************/\n\t\t\t\t$obj.data('als',\n\t\t\t\t{\n\t\t\t\t\tcontainer : $obj,\n\t\t\t\t\tinstance : instance,\n\t\t\t\t\toptions : $options,\n\t\t\t\t\tviewport : $viewport,\n\t\t\t\t\twrapper : $wrapper,\n\t\t\t\t\tprev : $prev,\n\t\t\t\t\tnext : $next,\n\t\t\t\t\titem : $item,\n\t\t\t\t\tnum_items : num_items,\n\t\t\t\t\twrapper_width : wrapper_width,\n\t\t\t\t\tviewport_width : viewport_width,\n\t\t\t\t\twrapper_height : wrapper_height,\n\t\t\t\t\tviewport_height : viewport_height,\n\t\t\t\t\tcurrent : current,\n\t\t\t\t\ttimer : timer\n\t\t\t\t});\n\n\t\t\t\tdata = $obj.data('als');\n\t\t\t\tals[instance] = data;\n\n\t\t\t\t/******************************************\n\t\t\t\t * prev and next buttons inizialization\n\t\t\t\t ******************************************/\n\n\t\t\t\t$next.on(\"click\",nextHandle);\n\t\t\t\t$prev.on(\"click\",prevHandle);\n\n\t\t\t\t/*********************************************\n\t\t\t\t * automatic scrolling function inizialization\n\t\t\t\t * if it is the case\n\t\t\t\t *********************************************/\n\t\t\t\tif ($options.autoscroll == \"yes\")\n\t\t\t\t{\n\t\t\t\t\t$.fn.als('start',instance);\n\t\t\t\t\t$wrapper.hover(function()\n\t\t\t\t\t{\n\t\t\t\t\t\t$.fn.als('stop',$(this).attr(\"id\"));\n\t\t\t\t\t},function()\n\t\t\t\t\t{\n\t\t\t\t\t\t$.fn.als('start',$(this).attr(\"id\"));\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\telse if ($options.autoscroll == \"no\") {\n\t\t\t\t\t$.fn.als('stop',instance);\n\t\t\t\t}\n\n\t\t\t\t/*******************************************\n\t\t\t\t * increasing instance number and\n\t\t\t\t * returning als variable now inizialized\n\t\t\t\t ******************************************/\n\t\t\t\tinstance++;\n\t\t\t\treturn als;\n\t\t\t});\n\t\t},\n\t\t/*****************************************************\n\t\t * step function for lists elements\n\t\t * @param {Object} id: instance or ID of the element\n\t\t * that calls the function\n\t\t *****************************************************/\n\t\tnext: function(id){\n\t\t\tid = find_instance(id);\n\t\t\tvar data = als[id],\n\t\t\t\tk1 = 0, k2 = 0;\n\t\t\t/***************************************************\n\t\t\t * depending on list orientation I calculate\n\t\t\t * the element horizontal or vertical movement\n\t\t\t ***************************************************/\n\t\t\tswitch(data.options.orientation)\n\t\t\t{\n\t\t\t\t/*****************************************\n\t\t\t\t * list orientation: horizontal\n\t\t\t\t ****************************************/\n\t\t\t\tcase \"horizontal\":\n\t\t\t\tdefault:\n\t\t\t\t\tvar spostamento_sx = 0,\n\t\t\t\t\t\tviewport_width = 0;\n\t\t\t\t\t/************************************************\n\t\t\t\t\t * depending on scrolling type I calculate\n\t\t\t\t\t * the movement and the repositioning of the\n\t\t\t\t\t * list elements\n\t\t\t\t\t ************************************************/\n\t\t\t\t\tswitch(data.options.circular)\n\t\t\t\t\t{\n\t\t\t\t\t\t/****************************\n\t\t\t\t\t\t * infinite scrolling: no\n\t\t\t\t\t\t ****************************/\n\t\t\t\t\t\tcase \"no\":\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t/********************************************************************\n\t\t\t\t\t\t\t * I calculate the elements' movement on the basis of the scrolling\n\t\t\t\t\t\t\t * items number starting from the current index\n\t\t\t\t\t\t\t ********************************************************************/\n\t\t\t\t\t\t\tfor (k1 = data.current; k1 < data.current + data.options.scrolling_items; k1++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tspostamento_sx += data.item.eq(k1).outerWidth(true);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t/****************************************************************\n\t\t\t\t\t\t\t * I modify the current element on the basis of the scrolling\n\t\t\t\t\t\t\t * elements number\n\t\t\t\t\t\t\t ****************************************************************/\n\t\t\t\t\t\t\tdata.current += data.options.scrolling_items;\n\n\t\t\t\t\t\t\t/*******************************************************************\n\t\t\t\t\t\t\t * I calculate the viewport width on the basis of the width of the\n\t\t\t\t\t\t\t * elements that will be visible AFTER the animation\n\t\t\t\t\t\t\t *******************************************************************/\n\t\t\t\t\t\t\tfor (k2 = data.current; k2 < data.current + data.options.visible_items; k2++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tviewport_width += data.item.eq(k2).outerWidth(true);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t/********************************************************\n\t\t\t\t\t\t\t * I animate the viewport width\n\t\t\t\t\t\t\t ********************************************************/\n\t\t\t\t\t\t\tdata.viewport.animate({\n\t\t\t\t\t\t\t\t\"width\": viewport_width\n\t\t\t\t\t\t\t}, 600);\n\n\t\t\t\t\t\t\t/**********************************************\n\t\t\t\t\t\t\t * I animate the scrolling elements\n\t\t\t\t\t\t\t *********************************************/\n\t\t\t\t\t\t\tdata.item.animate({\n\t\t\t\t\t\t\t\t\"left\": \"-=\" + spostamento_sx\n\t\t\t\t\t\t\t}, 600);\n\t\t\t\t\t\t\t/***********************************************************\n\t\t\t\t\t\t\t * after the animation of all elements has finished\n\t\t\t\t\t\t\t * (deferred object)\n\t\t\t\t\t\t\t ***********************************************************/\n\t\t\t\t\t\t\tdata.item.promise().done(function()\n\t\t\t\t\t\t\t{\t/****************************************************\n\t\t\t\t\t\t\t\t * I bind again the \"click\" action to the prev\n\t\t\t\t\t\t\t\t * and next buttons (unbinded to prevent undesirable\n\t\t\t\t\t\t\t\t * behaviour during the scrolling animation)\n\t\t\t\t\t\t\t\t ***************************************************/\n\t\t\t\t\t\t\t\tdata.next.on(\"click\",nextHandle);\n\t\t\t\t\t\t\t\tdata.prev.on(\"click\",prevHandle);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t/**********************************************************\n\t\t\t\t\t\t\t * visibility control of the prev and next buttons\n\t\t\t\t\t\t\t **********************************************************/\n\t\t\t\t\t\t\tif(data.current > 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdata.prev.show();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (data.current + data.options.visible_items >= data.num_items)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdata.next.hide();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t/****************************\n\t\t\t\t\t\t * infinite scrolling: yes\n\t\t\t\t\t\t ***************************/\n\t\t\t\t\t\tcase \"yes\":\n\t\t\t\t\t\t\tvar memo = 0, memo_index = [];\n\t\t\t\t\t\t\t/**************************************************************************\n\t\t\t\t\t\t\t * I calculate displacement and memorize indices of the elements that\n\t\t\t\t\t\t\t * I have to move because they will be then repositioned in the queue\n\t\t\t\t\t\t\t **************************************************************************/\n\t\t\t\t\t\t\tfor (k1 = data.current; k1 < data.current + data.options.scrolling_items; k1++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvar k3 = k1;\n\t\t\t\t\t\t\t\t/******************************************************\n\t\t\t\t\t\t\t\t * I control if I exceed the total number of elements\n\t\t\t\t\t\t\t\t ******************************************************/\n\t\t\t\t\t\t\t\tif(k1 >= data.num_items)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tk3 = k1 - data.num_items;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tspostamento_sx += data.item.eq(k3).outerWidth(true);\n\t\t\t\t\t\t\t\tmemo_index[memo]= k3;\n\t\t\t\t\t\t\t\tmemo ++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t/****************************************************************\n\t\t\t\t\t\t\t * edit current element as a function of the number of elements\n\t\t\t\t\t\t\t * to slide in a single step\n\t\t\t\t\t\t\t ****************************************************************/\n\t\t\t\t\t\t\tdata.current += data.options.scrolling_items;\n\n\t\t\t\t\t\t\t/******************************************************\n\t\t\t\t\t\t\t * I control if I exceed the total number of elements\n\t\t\t\t\t\t\t ******************************************************/\n\t\t\t\t\t\t\tif(data.current >= data.num_items)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdata.current -= data.num_items;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t/***********************************************************************\n\t\t\t\t\t\t\t * calculating the extent of the viewport based on the items that\n\t\t\t\t\t\t\t * will be visible after scrolling\n\t\t\t\t\t\t\t ***********************************************************************/\n\t\t\t\t\t\t\tfor (k2 = data.current; k2 < data.current + data.options.visible_items; k2++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvar k4 = k2;\n\t\t\t\t\t\t\t\t/*****************************************************\n\t\t\t\t\t\t\t\t * I control if I exceed the total number of elements\n\t\t\t\t\t\t\t\t *****************************************************/\n\t\t\t\t\t\t\t\tif(k2 >= data.num_items)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tk4 = k2 - data.num_items;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tviewport_width += data.item.eq(k4).outerWidth(true);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t/******************************************************\n\t\t\t\t\t\t\t * viewport width animation\n\t\t\t\t\t\t\t ******************************************************/\n\t\t\t\t\t\t\tdata.viewport.animate({\n\t\t\t\t\t\t\t\t\"width\": viewport_width\n\t\t\t\t\t\t\t}, 600);\n\n\t\t\t\t\t\t\t/******************************************************************\n\t\t\t\t\t\t\t * scrolling animation of elements and repositioning of elements\n\t\t\t\t\t\t\t * stored in the queue\n\t\t\t\t\t\t\t *****************************************************************/\n\t\t\t\t\t\t\tdata.item.animate({\n\t\t\t\t\t\t\t\t\"left\": \"-=\" + spostamento_sx\n\t\t\t\t\t\t\t}, 600);\n\t\t\t\t\t\t\t/***********************************************************\n\t\t\t\t\t\t\t * once the animation of all the elements has finished\n\t\t\t\t\t\t\t * (deferred object)\n\t\t\t\t\t\t\t ***********************************************************/\n\t\t\t\t\t\t\tdata.item.promise().done(function()\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t/****************************************************************************\n\t\t\t\t\t\t\t\t * repositioning is calculated based on the location of the last element of\n\t\t\t\t\t\t\t\t * the list, double check if I have to move the first element\n\t\t\t\t\t\t\t\t ****************************************************************************/\n\t\t\t\t\t\t\t\tvar position = data.item.last().position(),\n\t\t\t\t\t\t\t\t\triposizionamento_dx = position.left + data.item.last().outerWidth(true);\n\t\t\t\t\t\t\t\tfor(k5 = 0; k5 < memo_index.length; k5++)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif(memo_index[k5] == 0)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tvar position = data.item.last().position(),\n\t\t\t\t\t\t\t\t\t\triposizionamento_dx = position.left + data.item.last().outerWidth(true);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tdata.item.eq(memo_index[k5]).css(\"left\", riposizionamento_dx);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t/*********************************************\n\t\t\t\t\t\t\t\t * re bind buttons \"click\" event that have\n\t\t\t\t\t\t\t\t * been detached from the handle to handle\n\t\t\t\t\t\t\t\t * properly the time of animation\n\t\t\t\t\t\t\t\t ********************************************/\n\t\t\t\t\t\t\t\tdata.next.on(\"click\",nextHandle);\n\t\t\t\t\t\t\t\tdata.prev.on(\"click\",prevHandle);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t\t/**************************************\n\t\t\t\t * list orientation: vertical\n\t\t\t\t **************************************/\n\t\t\t\tcase \"vertical\":\n\t\t\t\t\tvar spostamento_top = 0,\n\t\t\t\t\t\tviewport_height = 0;\n\t\t\t\t\t/************************************************\n\t\t\t\t\t * depending on the type of sliding I calcule\n\t\t\t\t\t * the displacement and the repositioning of the\n\t\t\t\t\t * elements of the list\n\t\t\t\t\t ************************************************/\n\t\t\t\t\tswitch(data.options.circular)\n\t\t\t\t\t{\n\t\t\t\t\t\t/****************************\n\t\t\t\t\t\t * infinite scrolling: no\n\t\t\t\t\t\t ***************************/\n\t\t\t\t\t\tcase \"no\":\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t/********************************************************************\n\t\t\t\t\t\t\t * displacement calculation based on the number of elements to\n\t\t\t\t\t\t\t * slide in a single step\n\t\t\t\t\t\t\t ********************************************************************/\n\t\t\t\t\t\t\tfor (k1 = data.current; k1 < data.current+data.options.scrolling_items; k1++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tspostamento_top += data.item.eq(k1).outerHeight(true);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t/****************************************************************\n\t\t\t\t\t\t\t * I edit element current as a function of the number of elements\n\t\t\t\t\t\t\t * to slide in a single step\n\t\t\t\t\t\t\t ****************************************************************/\n\t\t\t\t\t\t\tdata.current += data.options.scrolling_items;\n\n\t\t\t\t\t\t\t/***********************************************************************\n\t\t\t\t\t\t\t * calculating the width of the viewport on the basis of the visible\n\t\t\t\t\t\t\t * elements AFTER the sliding animation\n\t\t\t\t\t\t\t ***********************************************************************/\n\t\t\t\t\t\t\tfor (k2 = data.current; k2 < data.current + data.options.visible_items; k2++) {\n\t\t\t\t\t\t\t\tviewport_height += data.item.eq(k2).outerHeight(true);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t/***************************************************\n\t\t\t\t\t\t\t * I animate the viewport width\n\t\t\t\t\t\t\t ***************************************************/\n\t\t\t\t\t\t\tdata.viewport.animate({\n\t\t\t\t\t\t\t\t\"height\": viewport_height\n\t\t\t\t\t\t\t}, 600);\n\t\t\t\t\t\t\t/****************************************\n\t\t\t\t\t\t\t * I animate the elements scrolling\n\t\t\t\t\t\t\t ****************************************/\n\t\t\t\t\t\t\tdata.item.animate({\n\t\t\t\t\t\t\t\t\"top\": \"-=\" + spostamento_top\n\t\t\t\t\t\t\t}, 600);\n\t\t\t\t\t\t\t/**********************************************************\n\t\t\t\t\t\t\t * once the animation of all the elements has finished\n\t\t\t\t\t\t\t * (deferred object)\n\t\t\t\t\t\t\t **********************************************************/\n\t\t\t\t\t\t\tdata.item.promise().done(function()\n\t\t\t\t\t\t\t{\t/*********************************************\n\t\t\t\t\t\t\t\t * re bind buttons \"click\" event that has\n\t\t\t\t\t\t\t\t * been detached from the handle to handle\n\t\t\t\t\t\t\t\t * properly the time of animation\n\t\t\t\t\t\t\t\t ********************************************/\n\t\t\t\t\t\t\t\tdata.next.on(\"click\",nextHandle);\n\t\t\t\t\t\t\t\tdata.prev.on(\"click\",prevHandle);\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t/****************************************************\n\t\t\t\t\t\t\t * control visibility of the scroll buttons on\n\t\t\t\t\t\t\t * the basis of the current element\n\t\t\t\t\t\t\t ****************************************************/\n\t\t\t\t\t\t\tif(data.current > 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdata.prev.show();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (data.current + data.options.visible_items >= data.num_items)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdata.next.hide();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t/****************************\n\t\t\t\t\t\t * infinite scrolling: yes\n\t\t\t\t\t\t ****************************/\n\t\t\t\t\t\tcase \"yes\":\n\t\t\t\t\t\t\tvar memo = 0, memo_index = [];\n\t\t\t\t\t\t\t/****************************************************************\n\t\t\t\t\t\t\t * displacement calculation based on the number of elements to\n\t\t\t\t\t\t\t * slide in a single step and memorization of items to reposition\n\t\t\t\t\t\t\t ****************************************************************/\n\t\t\t\t\t\t\tfor (k1 = data.current; k1 < data.current + data.options.scrolling_items; k1++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvar k3 = k1;\n\t\t\t\t\t\t\t\t/**********************************************\n\t\t\t\t\t\t\t\t * control that the index does not exceed the\n\t\t\t\t\t\t\t\t * total number of the elements\n\t\t\t\t\t\t\t\t *********************************************/\n\t\t\t\t\t\t\t\tif(k1 >= data.num_items)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tk3 = k1 - data.num_items;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tspostamento_top += data.item.eq(k3).outerHeight(true);\n\t\t\t\t\t\t\t\tmemo_index[memo]= k3;\n\t\t\t\t\t\t\t\tmemo ++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t/****************************************************************\n\t\t\t\t\t\t\t * edit current element on the basis of the number of elements\n\t\t\t\t\t\t\t * to slide in a single step\n\t\t\t\t\t\t\t ****************************************************************/\n\t\t\t\t\t\t\tdata.current += data.options.scrolling_items;\n\n\t\t\t\t\t\t\t/*************************************************\n\t\t\t\t\t\t\t * control that the index does not exceed the\n\t\t\t\t\t\t\t * total number of the elements\n\t\t\t\t\t\t\t ************************************************/\n\t\t\t\t\t\t\tif(data.current >= data.num_items)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdata.current -= data.num_items;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t/******************************************************************************\n\t\t\t\t\t\t\t * calculating the width of viewport on the basis of the visible elements\n\t\t\t\t\t\t\t * AFTER the scrolling\n\t\t\t\t\t\t\t ******************************************************************************/\n\t\t\t\t\t\t\tfor (k2 = data.current; k2 < data.current + data.options.visible_items; k2++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvar k4 = k2;\n\t\t\t\t\t\t\t\t/**********************************************\n\t\t\t\t\t\t\t\t * control that the index does not exceed the\n\t\t\t\t\t\t\t \t * total number of the elements\n\t\t\t\t\t\t\t\t *********************************************/\n\t\t\t\t\t\t\t\tif(k2 >= data.num_items)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tk4 = k2 - data.num_items;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tviewport_height += data.item.eq(k4).outerHeight(true);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t/*************************************************\n\t\t\t\t\t\t\t * I animate the viewport width\n\t\t\t\t\t\t\t *************************************************/\n\t\t\t\t\t\t\tdata.viewport.animate({\n\t\t\t\t\t\t\t\t\"height\": viewport_height\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t/****************************************************************\n\t\t\t\t\t\t\t * I animate the elements and reposition those previously stored\n\t\t\t\t\t\t\t ***************************************************************/\n\t\t\t\t\t\t\tdata.item.animate({\n\t\t\t\t\t\t\t\t\"top\": \"-=\" + spostamento_top\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t/************************************************************\n\t\t\t\t\t\t\t * once all the elements' animations has finished\n\t\t\t\t\t\t\t * (deferred object)\n\t\t\t\t\t\t\t ***********************************************************/\n\t\t\t\t\t\t\tdata.item.promise().done(function()\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t/************************************************************************\n\t\t\t\t\t\t\t\t * repositioning is calculated based on the location of the last element\n\t\t\t\t\t\t\t\t * of the list. Take care to the repositioning of the first element\n\t\t\t\t\t\t\t\t * that needs to be recalculated AFTER the last was eventually relocated\n\t\t\t\t\t\t\t\t ************************************************************************/\n\t\t\t\t\t\t\t\tvar position = data.item.last().position(),\n\t\t\t\t\t\t\t\t\triposizionamento_bottom = position.top + data.item.last().outerHeight(true);\n\t\t\t\t\t\t\t\tfor(k5 = 0; k5 < memo_index.length; k5++)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif(memo_index[k5] == 0)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tvar position = data.item.last().position(),\n\t\t\t\t\t\t\t\t\t\triposizionamento_bottom = position.top + data.item.last().outerHeight(true);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tdata.item.eq(memo_index[k5]).css(\"top\", riposizionamento_bottom);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t/*********************************************\n\t\t\t\t\t\t\t\t * re bind buttons \"click\" event that has\n\t\t\t\t\t\t\t\t * been detached from the handle to handle\n\t\t\t\t\t\t\t\t * properly the time of animation\n\t\t\t\t\t\t\t\t ********************************************/\n\t\t\t\t\t\t\t\tdata.next.on(\"click\",nextHandle);\n\t\t\t\t\t\t\t\tdata.prev.on(\"click\",prevHandle);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/************************************\n\t\t\t * save the data in als instance and\n\t\t\t * return als object\n\t\t\t ***********************************/\n\t\t\tals[id] = data;\n\t\t\treturn als;\n\t\t},\n\t\t/*****************************************************\n\t\t * sliding back function of the list elements\n\t\t * @param {Object} id: instance or ID of the element\n\t\t * that calls the function\n\t\t *****************************************************/\n\t\tprev: function(id){\n\t\t\tid = find_instance(id);\n\t\t\tvar data = als[id],\n\t\t\t\tk1 = 0, k2 = 0;\n\t\t\t/***************************************************\n\t\t\t * depending on the orientation of the list I\n\t\t\t * calculate the horizontal or vertical displacement\n\t\t\t * of the elements\n\t\t\t ***************************************************/\n\t\t\tswitch(data.options.orientation)\n\t\t\t{\n\t\t\t\t/***************************\n\t\t\t\t * horizontal orientation\n\t\t\t\t ***************************/\n\t\t\t\tcase \"horizontal\":\n\t\t\t\tdefault:\n\t\t\t\t\tvar spostamento_dx = 0,\n\t\t\t\t\t\tviewport_width = 0;\n\t\t\t\t\t/****************************************************\n\t\t\t\t\t * depending on the type of scroll (circular or not)\n\t\t\t\t\t * I calculate the displacement and the possible\n\t\t\t\t\t * repositioning of the elements of the list\n\t\t\t\t\t ****************************************************/\n\t\t\t\t\tswitch(data.options.circular)\n\t\t\t\t\t{\n\t\t\t\t\t\t/*****************************\n\t\t\t\t\t\t * circular scrolling: no\n\t\t\t\t\t\t *****************************/\n\t\t\t\t\t\tcase \"no\":\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t/***************************************************************\n\t\t\t\t\t\t\t * edit the current item index as a function of the elements to\n\t\t\t\t\t\t\t * slide in a single step: edit right away so that you can do\n\t\t\t\t\t\t\t * the next steps \"forward\"\n\t\t\t\t\t\t\t ***************************************************************/\n\t\t\t\t\t\t\tdata.current -= data.options.scrolling_items;\n\n\t\t\t\t\t\t\t/*******************************************************************\n\t\t\t\t\t\t\t * calculating the displacement of the elements according to the\n\t\t\t\t\t\t\t * number of elements to slide in a single step\n\t\t\t\t\t\t\t *******************************************************************/\n\t\t\t\t\t\t\tfor (k1 = data.current; k1 < data.current+data.options.scrolling_items; k1++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tspostamento_dx += data.item.eq(k1).outerWidth(true);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t/******************************************************************************\n\t\t\t\t\t\t\t * calculation of the viewport width on the basis of the visible elements\n\t\t\t\t\t\t\t * AFTER the scrolling (on the basis of their width)\n\t\t\t\t\t\t\t ******************************************************************************/\n\t\t\t\t\t\t\tfor (k2 = data.current; k2 < data.current + data.options.visible_items; k2++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tviewport_width += data.item.eq(k2).outerWidth(true);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t/*************************************************\n\t\t\t\t\t\t\t * animating the viewport width\n\t\t\t\t\t\t\t *************************************************/\n\t\t\t\t\t\t\tdata.viewport.animate({\n\t\t\t\t\t\t\t\t\"width\": viewport_width\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t/**********************************\n\t\t\t\t\t\t\t * animating elements scrolling\n\t\t\t\t\t\t\t **********************************/\n\t\t\t\t\t\t\tdata.item.animate({\n\t\t\t\t\t\t\t\t\"left\": \"+=\" + spostamento_dx\n\t\t\t\t\t\t\t}, 600);\n\t\t\t\t\t\t\t/***********************************************************\n\t\t\t\t\t\t\t * once all animations have finished\n\t\t\t\t\t\t\t * (deferred object)\n\t\t\t\t\t\t\t ***********************************************************/\n\t\t\t\t\t\t\tdata.item.promise().done(function()\n\t\t\t\t\t\t\t{\t/*********************************************\n\t\t\t\t\t\t\t\t * re bind buttons \"click\" event that have\n\t\t\t\t\t\t\t\t * been detached from the handle to manage\n\t\t\t\t\t\t\t\t * properly the time of animation\n\t\t\t\t\t\t\t\t ********************************************/\n\t\t\t\t\t\t\t\tdata.prev.on(\"click\",prevHandle);\n\t\t\t\t\t\t\t\tdata.next.on(\"click\",nextHandle);\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t/**********************************************************\n\t\t\t\t\t\t\t * control visibility of the scroll buttons\n\t\t\t\t\t\t\t **********************************************************/\n\t\t\t\t\t\t\tif(data.current <= 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdata.prev.hide();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (data.current + data.options.visible_items < data.num_items)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdata.next.show();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t/*****************************\n\t\t\t\t\t\t * circular scrolling: yes\n\t\t\t\t\t\t *****************************/\n\t\t\t\t\t\tcase \"yes\":\n\t\t\t\t\t\t\tvar memo = 0, memo_index = [];\n\t\t\t\t\t\t\t/***************************************************************\n\t\t\t\t\t\t\t * edit the current item index as a function of the elements\n\t\t\t\t\t\t\t * to slide in a single step: edit right away so that we can do\n\t\t\t\t\t\t\t * the next steps \"forward\"\n\t\t\t\t\t\t\t ***************************************************************/\n\t\t\t\t\t\t\tdata.current -= data.options.scrolling_items;\n\t\t\t\t\t\t\t/**************************************************\n\t\t\t\t\t\t\t * check if the current element has not index < 0\n\t\t\t\t\t\t\t **************************************************/\n\t\t\t\t\t\t\tif(data.current < 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdata.current += data.num_items;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t/****************************************************************\n\t\t\t\t\t\t\t * displacement calculation based on the elements to slide in a\n\t\t\t\t\t\t\t * single step and memorization of the items to reposition\n\t\t\t\t\t\t\t ****************************************************************/\n\t\t\t\t\t\t\tfor (k1 = data.current; k1 < data.current + data.options.scrolling_items; k1++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvar k3 = k1;\n\t\t\t\t\t\t\t\t/**********************************************\n\t\t\t\t\t\t\t\t * control that the index does not exceed the\n\t\t\t\t\t\t\t\t * total number of the elements\n\t\t\t\t\t\t\t\t *********************************************/\n\t\t\t\t\t\t\t\tif(k1 >= data.num_items)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tk3 = k1 - data.num_items;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tspostamento_dx += data.item.eq(k3).outerWidth(true);\n\t\t\t\t\t\t\t\tmemo_index[memo]= k3;\n\n\t\t\t\t\t\t\t\tmemo ++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t/******************************************************************************\n\t\t\t\t\t\t\t * calculating the width of the viewport on the basis of the\n\t\t\t\t\t\t\t * visible elements AFTER the scrolling\n\t\t\t\t\t\t\t ******************************************************************************/\n\t\t\t\t\t\t\tfor (k2 = data.current; k2 < data.current + data.options.visible_items; k2++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvar k4 = k2;\n\t\t\t\t\t\t\t\t/**********************************************\n\t\t\t\t\t\t\t\t * control that the index does not exceed the\n\t\t\t\t\t\t\t\t * total number of the elements\n\t\t\t\t\t\t\t\t *********************************************/\n\t\t\t\t\t\t\t\tif(k2 >= data.num_items)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tk4 = k2 - data.num_items;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tviewport_width += data.item.eq(k4).outerWidth(true);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t/************************************************************************\n\t\t\t\t\t\t\t * repositioning is calculated based on the location of the first element\n\t\t\t\t\t\t\t * of the list. Special care to the repositioning of the last element\n\t\t\t\t\t\t\t * that needs to be recalculated AFTER the first was eventually relocated\n\t\t\t\t\t\t\t ************************************************************************/\n\t\t\t\t\t\t\tvar position = data.item.first().position(),\n\t\t\t\t\t\t\t\triposizionamento_sx = position.left - data.wrapper_width;\n\n\t\t\t\t\t\t\tfor(k5 = 0; k5 < memo_index.length; k5++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdata.item.eq(memo_index[k5]).css(\"left\", riposizionamento_sx);\n\t\t\t\t\t\t\t\tif(memo_index[k5] == 0 && memo_index[k5-1] == data.num_items-1)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tvar position = data.item.first().position(),\n\t\t\t\t\t\t\t\t\t\triposizionamento_sx = position.left - data.wrapper_width;\n\t\t\t\t\t\t\t\t\tdata.item.eq(memo_index[k5-1]).css(\"left\", riposizionamento_sx);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t/************************************************************\n\t\t\t\t\t\t\t * timeout of 200ms is necessary to wait before making the\n\t\t\t\t\t\t\t * scrolling animation, otherwise we can not properly manage\n\t\t\t\t\t\t\t * the repositioning of the list elements\n\t\t\t\t\t\t\t ************************************************************/\n\t\t\t\t\t\t\tsetTimeout(function()\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t/****************************************\n\t\t\t\t\t\t\t\t * viewport width animation\n\t\t\t\t\t\t\t\t ****************************************/\n\t\t\t\t\t\t\t\tdata.viewport.animate({\n\t\t\t\t\t\t\t\t\t\"width\": viewport_width\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t/*******************************\n\t\t\t\t\t\t\t\t * list elements animation\n\t\t\t\t\t\t\t\t *******************************/\n\t\t\t\t\t\t\t\tdata.item.animate({\n\t\t\t\t\t\t\t\t\t\"left\": \"+=\" + spostamento_dx\n\t\t\t\t\t\t\t\t}, 600);\n\t\t\t\t\t\t\t\t/**********************************************************\n\t\t\t\t\t\t\t\t * once all elements animations have finished\n\t\t\t\t\t\t\t\t * (deferred object)\n\t\t\t\t\t\t\t\t **********************************************************/\n\t\t\t\t\t\t\t\tdata.item.promise().done(function()\n\t\t\t\t\t\t\t\t{\t/*********************************************\n\t\t\t\t\t\t\t\t\t * re bind buttons \"click\" event that have\n\t\t\t\t\t\t\t\t\t * been detached from the handle to manage\n\t\t\t\t\t\t\t\t\t * properly the time of animation\n\t\t\t\t\t\t\t\t\t ********************************************/\n\t\t\t\t\t\t\t\t\tdata.prev.on(\"click\",prevHandle);\n\t\t\t\t\t\t\t\t\tdata.next.on(\"click\",nextHandle);\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}, 200);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\t/*************************\n\t\t\t\t * vertical orientation\n\t\t\t\t ************************/\n\t\t\t\tcase \"vertical\":\n\t\t\t\t\tvar spostamento_bottom = 0,\n\t\t\t\t\t\tviewport_height = 0;\n\n\t\t\t\t\tswitch(data.options.circular)\n\t\t\t\t\t{\n\t\t\t\t\t\t/*****************************\n\t\t\t\t\t\t * circular scrolling: no\n\t\t\t\t\t\t ****************************/\n\t\t\t\t\t\tcase \"no\":\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t/***************************************************************\n\t\t\t\t\t\t\t * edit the current item index as a function of the elements to\n\t\t\t\t\t\t\t * slide in a single step: edit right away so that we can do\n\t\t\t\t\t\t\t * the next steps \"forward\"\n\t\t\t\t\t\t\t ***************************************************************/\n\t\t\t\t\t\t\tdata.current -= data.options.scrolling_items;\n\t\t\t\t\t\t\t/****************************************************************\n\t\t\t\t\t\t\t * displacement calculation based on the elements to slide\n\t\t\t\t\t\t\t * in a single step\n\t\t\t\t\t\t\t ****************************************************************/\n\t\t\t\t\t\t\tfor (k1 = data.current; k1 < data.current+data.options.scrolling_items; k1++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tspostamento_bottom += data.item.eq(k1).outerHeight(true);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t/******************************************************************************\n\t\t\t\t\t\t\t * calculating the width of the viewport on the basis of the visible elements\n\t\t\t\t\t\t\t * AFTER the scrolling\n\t\t\t\t\t\t\t ******************************************************************************/\n\t\t\t\t\t\t\tfor (k2 = data.current; k2 < data.current + data.options.visible_items; k2++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tviewport_height += data.item.eq(k2).outerHeight(true);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t/***********************************************\n\t\t\t\t\t\t\t * viewport width animation\n\t\t\t\t\t\t\t **********************************************/\n\t\t\t\t\t\t\tdata.viewport.animate({\n\t\t\t\t\t\t\t\t\"height\": viewport_height\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t/*****************************************\n\t\t\t\t\t\t\t * list elements scrolling animation\n\t\t\t\t\t\t\t *****************************************/\n\t\t\t\t\t\t\tdata.item.animate({\n\t\t\t\t\t\t\t\t\"top\": \"+=\" + spostamento_bottom\n\t\t\t\t\t\t\t}, 600);\n\t\t\t\t\t\t\t/**********************************************************\n\t\t\t\t\t\t\t * once all elemets animations have finished\n\t\t\t\t\t\t\t * (deferred object)\n\t\t\t\t\t\t\t **********************************************************/\n\t\t\t\t\t\t\tdata.item.promise().done(function()\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t/*********************************************\n\t\t\t\t\t\t\t\t * re bind buttons \"click\" event that have\n\t\t\t\t\t\t\t\t * been detached from the handle to manage\n\t\t\t\t\t\t\t\t * properly the time of animation\n\t\t\t\t\t\t\t\t ********************************************/\n\t\t\t\t\t\t\t\tdata.prev.on(\"click\",prevHandle);\n\t\t\t\t\t\t\t\tdata.next.on(\"click\",nextHandle);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t/***********************************************************\n\t\t\t\t\t\t\t * management of visibility of forward and backward buttons\n\t\t\t\t\t\t\t **********************************************************/\n\t\t\t\t\t\t\tif(data.current <= 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdata.prev.hide();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (data.current + data.options.visible_items < data.num_items)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdata.next.show();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"yes\":\n\t\t\t\t\t\t/*****************************\n\t\t\t\t\t\t * circular scrolling: yes\n\t\t\t\t\t\t *****************************/\n\t\t\t\t\t\t\tvar memo = 0, memo_index = [];\n\t\t\t\t\t\t\t/***************************************************************\n\t\t\t\t\t\t\t * edit the current item index as a function of the elements to\n\t\t\t\t\t\t\t * slide in a single step: edit right away so that we can do\n\t\t\t\t\t\t\t * the next steps \"forward\"\n\t\t\t\t\t\t\t ***************************************************************/\n\t\t\t\t\t\t\tdata.current -= data.options.scrolling_items;\n\t\t\t\t\t\t\t/*********************************************************\n\t\t\t\t\t\t\t * control that the current element has not index < 0\n\t\t\t\t\t\t\t *********************************************************/\n\t\t\t\t\t\t\tif(data.current < 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdata.current += data.num_items;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t/********************************************************************\n\t\t\t\t\t\t\t * displacement calculation based on the elements to slide in a\n\t\t\t\t\t\t\t * single step and memorization of those that have to be repositioned\n\t\t\t\t\t\t\t * later\n\t\t\t\t\t\t\t ********************************************************************/\n\t\t\t\t\t\t\tfor (k1 = data.current; k1 < data.current + data.options.scrolling_items; k1++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvar k3 = k1;\n\t\t\t\t\t\t\t\t/***********************************************\n\t\t\t\t\t\t\t\t * control that the index does not exceed the\n\t\t\t\t\t\t\t\t * total number of the elements\n\t\t\t\t\t\t\t\t ***********************************************/\n\t\t\t\t\t\t\t\tif(k1 >= data.num_items)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tk3 = k1 - data.num_items;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tspostamento_bottom += data.item.eq(k3).outerHeight(true);\n\t\t\t\t\t\t\t\tmemo_index[memo]= k3;\n\n\t\t\t\t\t\t\t\tmemo ++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t/******************************************************************************\n\t\t\t\t\t\t\t * calculating the width of the viewport on the basis of the visible elements\n\t\t\t\t\t\t\t * AFTER the scrolling\n\t\t\t\t\t\t\t ******************************************************************************/\n\t\t\t\t\t\t\tfor (k2 = data.current; k2 < data.current + data.options.visible_items; k2++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvar k4 = k2;\n\t\t\t\t\t\t\t\t/***********************************************\n\t\t\t\t\t\t\t\t * control that the index does not exceed the\n\t\t\t\t\t\t\t\t * total number of the elements\n\t\t\t\t\t\t\t\t ***********************************************/\n\t\t\t\t\t\t\t\tif(k2 >= data.num_items)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tk4 = k2 - data.num_items;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tviewport_height += data.item.eq(k4).outerHeight(true);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t/************************************************************************\n\t\t\t\t\t\t\t * repositioning is calculated based on the location of the first element\n\t\t\t\t\t\t\t * of the list. Special care to the repositioning of the last element\n\t\t\t\t\t\t\t * that needs to be recalculated AFTER the first was eventually relocated\n\t\t\t\t\t\t\t ************************************************************************/\n\t\t\t\t\t\t\tvar position = data.item.first().position(),\n\t\t\t\t\t\t\t\triposizionamento_top = position.top - data.wrapper_height;\n\t\t\t\t\t\t\tfor(k5 = 0; k5 < memo_index.length; k5++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdata.item.eq(memo_index[k5]).css(\"top\", riposizionamento_top);\n\t\t\t\t\t\t\t\tif(memo_index[k5] == 0 && memo_index[k5-1] == data.num_items-1)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tvar position = data.item.first().position(),\n\t\t\t\t\t\t\t\t\t\triposizionamento_top = position.top - data.wrapper_height;\n\t\t\t\t\t\t\t\t\tdata.item.eq(memo_index[k5-1]).css(\"top\", riposizionamento_top);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t/************************************************************\n\t\t\t\t\t\t\t * timeout of 200ms is necessary to wait before making the\n\t\t\t\t\t\t\t * scrolling animation, otherwise we can not properly manage\n\t\t\t\t\t\t\t * the repositioning of the list elements\n\t\t\t\t\t\t\t ************************************************************/\n\t\t\t\t\t\t\tsetTimeout(function()\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t/*********************************************\n\t\t\t\t\t\t\t\t * viewport width animation\n\t\t\t\t\t\t\t\t *********************************************/\n\t\t\t\t\t\t\t\tdata.viewport.animate({\n\t\t\t\t\t\t\t\t\t\"height\": viewport_height\n\t\t\t\t\t\t\t\t}, 600);\n\t\t\t\t\t\t\t\t/************************************\n\t\t\t\t\t\t\t\t * list elements scrolling animation\n\t\t\t\t\t\t\t\t ***********************************/\n\t\t\t\t\t\t\t\tdata.item.animate({\n\t\t\t\t\t\t\t\t\t\"top\": \"+=\" + spostamento_bottom\n\t\t\t\t\t\t\t\t}, 600);\n\t\t\t\t\t\t\t\t/***********************************************************\n\t\t\t\t\t\t\t\t * once all elements animations have finished\n\t\t\t\t\t\t\t\t * (deferred object)\n\t\t\t\t\t\t\t\t **********************************************************/\n\t\t\t\t\t\t\t\tdata.item.promise().done(function()\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t/*********************************************\n\t\t\t\t\t\t\t\t\t * re bind buttons \"click\" event that have\n\t\t\t\t\t\t\t\t\t * been detached from the handle to manage\n\t\t\t\t\t\t\t\t\t * properly the time of animation\n\t\t\t\t\t\t\t\t\t ********************************************/\n\t\t\t\t\t\t\t\t\tdata.prev.on(\"click\",prevHandle);\n\t\t\t\t\t\t\t\t\tdata.next.on(\"click\",nextHandle);\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}, 200);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/************************************\n\t\t\t * saving als instance data and\n\t\t\t * returning als object\n\t\t\t ***********************************/\n\t\t\tals[id] = data;\n\t\t\treturn als;\n\t\t},\n\t\t/**************************************************************\n\t\t * start function for automatic scrolling\n\t\t * @param {Object} id: instance or ID of the element that has\n\t\t * called the function\n\t\t **************************************************************/\n\t\tstart: function(id){\n\t\t\tid = find_instance(id);\n\t\t\tvar data = als[id];\n\t\t\t/**********************************************************\n\t\t\t * stopping any previous automatic scrolling\n\t\t\t *********************************************************/\n\t\t\tif(data.timer != 0)\n\t\t\t{\n\t\t\t\tclearInterval(data.timer);\n\t\t\t}\n\t\t\t/************************************\n\t\t\t * depending on the direction you\n\t\t\t * choose automatic scrolling begins\n\t\t\t ***********************************/\n\t\t\tswitch(data.options.direction)\n\t\t\t{\n\t\t\t\t/************************************************\n\t\t\t\t * if left or up (that means \"forward\")\n\t\t\t\t ************************************************/\n\t\t\t\tcase \"left\":\n\t\t\t\tcase \"up\":\n\t\t\t\tdefault:\n\t\t\t\t\t/************************************\n\t\t\t\t\t * detachment from the handler buttons\n\t\t\t\t\t * and the animation forward start\n\t\t\t\t\t * (next function)\n\t\t\t\t\t ************************************/\n\t\t\t\t\tdata.timer = setInterval(function(){\n\t\t\t\t\t\tdata.next.off();\n\t\t\t\t\t\tdata.prev.off();\n\t\t\t\t\t\t$.fn.als('next',id);\n\t\t\t\t\t\t},data.options.interval);\n\t\t\t\tbreak;\n\t\t\t\t/***************************************************\n\t\t\t\t * if right or down (that means \"backward\")\n\t\t\t\t ***************************************************/\n\t\t\t\tcase \"right\":\n\t\t\t\tcase \"down\":\n\t\t\t\t\t/************************************\n\t\t\t\t\t * detachment from the handler buttons\n\t\t\t\t\t * and the animation forward start\n\t\t\t\t\t * (prev function)\n\t\t\t\t\t ************************************/\n\t\t\t\t\tdata.timer = setInterval(function(){\n\t\t\t\t\t\tdata.prev.off();\n\t\t\t\t\t\tdata.next.off();\n\t\t\t\t\t\t$.fn.als('prev',id);\n\t\t\t\t\t\t},data.options.interval);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/************************************\n\t\t\t * saving als instance data and\n\t\t\t * returning als object\n\t\t\t ***********************************/\n\t\t\tals[id] = data;\n\t\t\treturn als;\n\t\t},\n\t\t/**************************************************************\n\t\t * stop function for automatic scrolling\n\t\t * @param {Object} id: instance or ID of the element that\n\t\t * called the function\n\t\t **************************************************************/\n\t\tstop: function(id)\n\t\t{\n\t\t\tid = find_instance(id);\n\t\t\tvar data = als[id];\n\t\t\t/********************************\n\t\t\t * stop autoscrolling\n\t\t\t *******************************/\n\t\t\tclearInterval(data.timer);\n\t\t\t/************************************\n\t\t\t * saving data into als instance\n\t\t\t * and returning als object\n\t\t\t ***********************************/\n\t\t\tals[id] = data;\n\t\t\treturn als;\n\t\t},\n\t\t/*****************************\n\t\t * function that destroys als\n\t\t *****************************/\n\t\tdestroy : function(){\n         \t$(window).unbind('.als');\n            instance = 0;\n\t\t},\n\t}\n\n\t/**************************\n\t **************************\n\t * service functions\n\t **************************\n\t **************************/\n\n\t/********************************************************************\n\t * function to find the current plugin instance\n\t * @param {Object} id: plugin instance od ID of the element that\n\t * called the plugin\n\t ********************************************************************/\n\tfunction find_instance(id)\n\t{\n\t\tif(typeof(id) === \"string\")\n\t\t{\n\t\t\tvar position = id.indexOf(\"_\");\n\t\t\tif(position != -1)\n\t\t\t{\n\t\t\t\tid = id.substr(position+1);\n\t\t\t}\n\t\t}\n\t\treturn id\n\t}\n\n\t/****************************************************\n\t * function that manages \"click\" action on next button\n\t * @param {Object} e event\n\t ***************************************************/\n\tfunction nextHandle(e)\n\t{\n\t\te.preventDefault();\n\t\tvar id = find_instance($(this).attr(\"data-id\")),\n\t\t\tdata = als[id];\n\t\t/*********************************************\n\t\t * unbinding next and prev buttons so that\n\t\t * they don't interfere with current animation\n\t\t ********************************************/\n\t\t$(this).off();\n\t\tdata.prev.off();\n\t\t/********************************************\n\t\t * calling next function on this instance\n\t\t ********************************************/\n\t\t$.fn.als('next',id);\n\t}\n\n\t/******************************************************\n\t * function that manages \"click\" action on prev button\n\t * @param {Object} e event\n\t ******************************************************/\n\tfunction prevHandle(e)\n\t{\n\t\te.preventDefault();\n\t\tvar id = find_instance($(this).attr(\"data-id\")),\n\t\t\tdata = als[id];\n\t\t/***********************************************\n\t\t * unbinding next and prev buttons so that\n\t\t * they don't interfere with current animation\n\t\t **********************************************/\n\t\t$(this).off();\n\t\tdata.next.off();\n\t\t/*********************************************\n\t\t * calling prev function on this instance\n\t\t *********************************************/\n\t\t$.fn.als('prev',id);\n\t}\n\n\t/********************************************************************\n\t * function that generates the plugin and instantiates its methods\n\t * @param {Object} method\n\t *******************************************************************/\n\t$.fn.als = function( method )\n\t{\n\t    if ( methods[method] )\n\t\t{\n\t    \treturn methods[ method ].apply( this, Array.prototype.slice.call( arguments, 1 ));\n\t    }\n\t\telse if ( typeof method === 'object' || ! method )\n\t\t{\n\t    \treturn methods.init.apply( this, arguments );\n\t    }\n\t\telse\n\t\t{\n\t    \t$.error( 'Method ' +  method + ' does not exist on jQuery.als' );\n\t    }\n  \t};\n\n})(jQuery);\n","undoManager":{"mark":37,"position":38,"stack":[[{"start":{"row":53,"column":19},"end":{"row":53,"column":20},"action":"remove","lines":[" "],"id":7}],[{"start":{"row":53,"column":19},"end":{"row":53,"column":20},"action":"insert","lines":[" "],"id":8}],[{"start":{"row":53,"column":20},"end":{"row":53,"column":21},"action":"remove","lines":["3"],"id":9}],[{"start":{"row":53,"column":20},"end":{"row":53,"column":21},"action":"insert","lines":["4"],"id":10}],[{"start":{"row":54,"column":22},"end":{"row":54,"column":23},"action":"remove","lines":["1"],"id":11}],[{"start":{"row":54,"column":22},"end":{"row":54,"column":23},"action":"insert","lines":["2"],"id":12}],[{"start":{"row":56,"column":17},"end":{"row":56,"column":18},"action":"remove","lines":["o"],"id":13}],[{"start":{"row":56,"column":16},"end":{"row":56,"column":17},"action":"remove","lines":["n"],"id":14}],[{"start":{"row":56,"column":16},"end":{"row":56,"column":17},"action":"insert","lines":[""],"id":15}],[{"start":{"row":56,"column":17},"end":{"row":56,"column":18},"action":"insert","lines":[""],"id":16}],[{"start":{"row":56,"column":17},"end":{"row":56,"column":18},"action":"remove","lines":[""],"id":18}],[{"start":{"row":56,"column":16},"end":{"row":56,"column":17},"action":"remove","lines":[""],"id":19}],[{"start":{"row":56,"column":16},"end":{"row":56,"column":17},"action":"insert","lines":["y"],"id":20}],[{"start":{"row":56,"column":17},"end":{"row":56,"column":18},"action":"insert","lines":["e"],"id":21}],[{"start":{"row":56,"column":18},"end":{"row":56,"column":19},"action":"insert","lines":["s"],"id":22}],[{"start":{"row":58,"column":18},"end":{"row":58,"column":19},"action":"remove","lines":["0"],"id":23}],[{"start":{"row":58,"column":17},"end":{"row":58,"column":18},"action":"remove","lines":["0"],"id":24}],[{"start":{"row":58,"column":16},"end":{"row":58,"column":17},"action":"remove","lines":["0"],"id":25}],[{"start":{"row":58,"column":15},"end":{"row":58,"column":16},"action":"remove","lines":["4"],"id":26}],[{"start":{"row":58,"column":15},"end":{"row":58,"column":16},"action":"insert","lines":["5"],"id":27}],[{"start":{"row":58,"column":16},"end":{"row":58,"column":17},"action":"insert","lines":["0"],"id":28}],[{"start":{"row":58,"column":17},"end":{"row":58,"column":18},"action":"insert","lines":["0"],"id":29}],[{"start":{"row":58,"column":18},"end":{"row":58,"column":19},"action":"insert","lines":["0"],"id":30}],[{"start":{"row":59,"column":17},"end":{"row":59,"column":21},"action":"remove","lines":["left"],"id":31},{"start":{"row":59,"column":17},"end":{"row":59,"column":18},"action":"insert","lines":["r"]}],[{"start":{"row":59,"column":18},"end":{"row":59,"column":19},"action":"insert","lines":["i"],"id":32}],[{"start":{"row":59,"column":19},"end":{"row":59,"column":20},"action":"insert","lines":["g"],"id":33}],[{"start":{"row":59,"column":20},"end":{"row":59,"column":21},"action":"insert","lines":["t"],"id":34}],[{"start":{"row":59,"column":21},"end":{"row":59,"column":22},"action":"insert","lines":["h"],"id":35}],[{"start":{"row":59,"column":21},"end":{"row":59,"column":22},"action":"remove","lines":["h"],"id":36}],[{"start":{"row":59,"column":20},"end":{"row":59,"column":21},"action":"remove","lines":["t"],"id":37}],[{"start":{"row":59,"column":20},"end":{"row":59,"column":21},"action":"insert","lines":["h"],"id":38}],[{"start":{"row":59,"column":21},"end":{"row":59,"column":22},"action":"insert","lines":["t"],"id":39}],[{"start":{"row":59,"column":17},"end":{"row":59,"column":22},"action":"remove","lines":["right"],"id":40},{"start":{"row":59,"column":17},"end":{"row":59,"column":18},"action":"insert","lines":["r"]}],[{"start":{"row":59,"column":17},"end":{"row":59,"column":18},"action":"remove","lines":["r"],"id":41}],[{"start":{"row":59,"column":17},"end":{"row":59,"column":18},"action":"insert","lines":["l"],"id":42}],[{"start":{"row":59,"column":18},"end":{"row":59,"column":19},"action":"insert","lines":["e"],"id":43}],[{"start":{"row":59,"column":19},"end":{"row":59,"column":20},"action":"insert","lines":["f"],"id":44}],[{"start":{"row":59,"column":20},"end":{"row":59,"column":21},"action":"insert","lines":["t"],"id":45}],[{"start":{"row":59,"column":22},"end":{"row":60,"column":0},"action":"insert","lines":["",""],"id":46},{"start":{"row":60,"column":0},"end":{"row":60,"column":5},"action":"insert","lines":["\t\t\t\t\t"]}]]},"ace":{"folds":[],"scrolltop":840,"scrollleft":0,"selection":{"start":{"row":17,"column":25},"end":{"row":17,"column":25},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":{"row":35,"state":"no_regex","mode":"ace/mode/javascript"}},"timestamp":1497006846310}